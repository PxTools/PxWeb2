import { Note } from '../../shared-types/note';
import { PxTableMetadata } from '../../shared-types/pxTableMetadata';
import { Value } from '../../shared-types/value';
import { Variable } from '../../shared-types/variable';
import { VartypeEnum } from '../../shared-types/vartypeEnum';

// Internal type holding mandatory and non mandatory notes for a table
export type tableNoteCollection = {
  SymbolExplanationNotes: { [key: string]: string };
  mandatoryNotes: noteCollection;
  nonMandatoryNotes: noteCollection;
};

// Internal type holding table, variable and value notes.
export type noteCollection = {
  notesCount: number;
  tableLevelNotes: string[];
  variableNotes: variableNotes[];
};

// Internal type holding notes for a variable.
export type variableNotes = {
  variableCode: string;
  variableName: string;
  notes: string[];
  valueNotes: valueNotes[];
};

// Internal type holding notes for a value.
export type valueNotes = {
  valueCode: string;
  valueName: string;
  notes: string[];
};

export function getNotes(
  totalMetadata: PxTableMetadata, // PxTableMetadata from the /metadata API-endpoint
  selectionMetadata: PxTableMetadata, // PxTableMetadata from the /data API-endpoint
  specialCharacters: string[], // Special characters from the config
): tableNoteCollection {
  const notes: tableNoteCollection = {
    SymbolExplanationNotes: {},
    mandatoryNotes: {
      notesCount: 0,
      tableLevelNotes: [],
      variableNotes: [],
    },
    nonMandatoryNotes: {
      notesCount: 0,
      tableLevelNotes: [],
      variableNotes: [],
    },
  };

  if (!totalMetadata || !selectionMetadata) {
    return notes;
  }

  if (totalMetadata.notes) {
    // Get notes at table level
    for (const note of totalMetadata.notes) {
      if (isSymbolExplanationNote(note, specialCharacters)) {
        addToSymbolExplanationNotes(note, notes, specialCharacters);
      } else if (note.mandatory) {
        notes.mandatoryNotes.notesCount++;
        notes.mandatoryNotes.tableLevelNotes.push(note.text);
      } else {
        notes.nonMandatoryNotes.notesCount++;
        notes.nonMandatoryNotes.tableLevelNotes.push(note.text);
      }
    }

    // Check if there are any autogenerated symbol explanation notes from the data API-call.
    getSymbolExplanationNotes(selectionMetadata, notes, specialCharacters);

    // Get notes for variables
    for (const variable of totalMetadata.variables) {
      getNotesForVariable(variable, notes);
    }
  }

  return notes;
}

// Get symbol explanation notes
function getSymbolExplanationNotes(
  pxMetadata: PxTableMetadata,
  notes: tableNoteCollection,
  specialCharacters: string[],
): void {
  if (pxMetadata.notes) {
    for (const note of pxMetadata.notes) {
      if (isSymbolExplanationNote(note, specialCharacters)) {
        addToSymbolExplanationNotes(note, notes, specialCharacters);
      }
    }
  }
}

// Check if a note is a symbol explanation note
function isSymbolExplanationNote(
  note: Note,
  specialCharacters: string[],
): boolean {
  return getSymbolExplanationKey(note, specialCharacters) !== undefined;
}

// Get the symbol explanation key for a note
function getSymbolExplanationKey(
  note: Note,
  specialCharacters: string[],
): string | undefined {
  return specialCharacters.find(
    (char) =>
      note.text.startsWith(char + ' ') || note.text.includes('(' + char + ')'),
  );
}

// Add a symbol explanation note to the collection
function addToSymbolExplanationNotes(
  note: Note,
  notes: tableNoteCollection,
  specialCharacters: string[],
): void {
  const symbolExplanationKey = getSymbolExplanationKey(note, specialCharacters);
  if (
    symbolExplanationKey &&
    !notes.SymbolExplanationNotes[symbolExplanationKey]
  ) {
    notes.SymbolExplanationNotes[symbolExplanationKey] = note.text;
  }
}

function getNotesForVariable(
  variable: Variable,
  notes: tableNoteCollection,
): void {
  // Get notes at variable level
  if (variable.notes && variable.notes.length > 0) {
    for (const note of variable.notes) {
      if (note.mandatory) {
        addVariableNote(variable, note, notes.mandatoryNotes);
      } else {
        addVariableNote(variable, note, notes.nonMandatoryNotes);
      }
    }
  }
  // Get notes at value level
  if (variable.values) {
    for (const value of variable.values) {
      getNotesForValue(variable, value, notes);
    }
  }
  if (variable.type === VartypeEnum.TIME_VARIABLE) {
    sortTimeValueNotes(variable, notes);
  }
}

// Sort value notes for time variables. Last value should be first in the list
function sortTimeValueNotes(
  variable: Variable,
  notes: tableNoteCollection,
): void {
  const variableNotes = notes.mandatoryNotes.variableNotes.find(
    (vn) => vn.variableCode === variable.id,
  );
  if (variableNotes) {
    variableNotes.valueNotes.sort((b, a) =>
      a.valueCode.localeCompare(b.valueCode),
    );
  }
}

// Get all notes for value
function getNotesForValue(
  variable: Variable,
  value: Value,
  notes: tableNoteCollection,
): void {
  if (value.notes && value.notes.length > 0) {
    for (const note of value.notes) {
      if (note.mandatory) {
        addValueNote(variable, value, note, notes.mandatoryNotes);
      } else {
        addValueNote(variable, value, note, notes.nonMandatoryNotes);
      }
    }
  }
}

// Add a note to a variable
function addVariableNote(
  variable: Variable,
  note: Note,
  collection: noteCollection,
): void {
  const existingVariableNote = collection.variableNotes.find(
    (vn) => vn.variableCode === variable.id,
  );
  if (existingVariableNote) {
    existingVariableNote.notes.push(note.text);
  } else {
    const newVariableNote: variableNotes = {
      variableCode: variable.id,
      variableName: variable.label,
      notes: [note.text],
      valueNotes: [],
    };
    collection.variableNotes.push(newVariableNote);
  }
  collection.notesCount++;
}

// Add a note to a value
function addValueNote(
  variable: Variable,
  value: Value,
  note: Note,
  collection: noteCollection,
): void {
  const existingVariableNote = collection.variableNotes.find(
    (vn) => vn.variableCode === variable.id,
  );
  if (existingVariableNote) {
    const existingValueNote = existingVariableNote.valueNotes.find(
      (vn) => vn.valueCode === value.code,
    );
    if (existingValueNote) {
      existingValueNote.notes.push(note.text);
    } else {
      const newValueNote: valueNotes = {
        valueCode: value.code,
        valueName: value.label,
        notes: [note.text],
      };
      existingVariableNote.valueNotes.push(newValueNote);
    }
  } else {
    const newVariableNote: variableNotes = {
      variableCode: variable.id,
      variableName: variable.label,
      notes: [],
      valueNotes: [
        {
          valueCode: value.code,
          valueName: value.label,
          notes: [note.text],
        },
      ],
    };
    collection.variableNotes.push(newVariableNote);
  }
  collection.notesCount++;
}
